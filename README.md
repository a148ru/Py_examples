## Последовательности и коллекции

Различают упорядочные и неупорядоченные коллекции (как set и dict)

- строки (str,bytes,unicode) - это последовательности

- reversed: обратный порядоск с функцией reversed

```python
a = reversed('hello')
```

- typle: упорядоченная коллекция из n значений любого типа (n>=0) (кортеж)

```python
a= (1, 2, 3)
b=('a', 1, 'python', (1, 2))
b[2]='something else' #возвращает ошибку типа TypeError
```

Поддерживает индексацию, неизменяемый, хешируемый, если все его члены хешируемы.

- list: Упорядоченная коллекция из n значений(n>=0)

```python
a=[1, 2, 3]
b=['a', 1, 'python',(1, 2),[1, 2]]
b[2]='something else' #такое присвоение разрешено
```

Не хешируемый, изменяемый

- set: неупорядоченная коллекция уникальных значений. Элементы должны быть хешируемыми

```python
a={1, 2, 'a'}
```
- dict: неупорядоченная оллекция уникальных пар *ключ-значение*, ключи должны быть хешируемыми

```python
a = {1: 'one', 2: 'two'}
b = {'a':[1, 2, 3], 'b': 'a string'}
```

Объект явдяется хешируемым, если он имеет хещ-значение, которое никогда не меняется в течении его жизни (для этого нужен метод *\_\_hash\_\_()*), и может сраниваться с другими объектами (для этого нужен метод *\_\_eq\_\_()*). Хешируемые объекты, которые сравниваются на равенство, должны иметь одинаковое хеш-значение.

## Изменяемые и незменяемые типы данных

##### Примеры неизменяемых типов данных

- int, long, float, complex
- str
- bytes
- tuple
- frozenset

##### Примеры изменяемых типов данных

- bytearray
- list
- set
- dict

## Типы коллекций

#### Списки (lists)

###### list - это просто упорядоченная коллекция допустимых значений.

```python
int_list = [1,2,3]
string_list = ['abc', 'defghi']
```

###### список может быть пустым

```python
empty_list = []
```

###### Элементы списка не ограничены одним типом данных

```python
mixed_list = [1, 'abc', True, 2.34, None]
```

###### Список может содержать в качестве элемента другой список

```python
nested_list = [['a', 'b', 'c'], [1, 2, 3]]
```

###### Доступ к элементам списка может осуществляться через индекс, или числовое представление их положения. Индексация с **0**

```python
names = ['Alice', 'Bob', 'Craig', 'Diana', 'Eric']
print(names[0]) #Alice
print(names[2]) #Craig
```

###### Индексы могут быть отрицательными, что означает отчет с конца списка

```python
print(names[-1]) #Eric
print(names[-4]) #Bob
```

###### Списки являются изменяемыми, значения в них можно менять, кроме того, можно добавлять и удалять элементы из списка

```python
names[0]='Ann'
names.append('Sia')
print(names) # ['Ann','Bob','Craig', 'Diana', 'Eric', 'Sia']
```

###### Добавить новый элемент в список по заданному индексу можно при помощи команды *L.insert(index,object)*

```python
names.insert(1, 'Nikki')
print(names) #  ['Ann', 'Nikki', 'Bob', 'Craig, 'Diana', 'Eric', 'Sia']
```

###### Удалить первое вхождение можно с помощью команды *L.remove(value)* (возвращает None)

```python
names.remove('Bob')
# ['Ann', 'Nikki', 'Craig, 'Diana', 'Eric', 'Sia']
```

###### Получить индекс в списке первого элемента, значение которого равно *x* (при отсутствии такого элемента выдаст ошибку)

```python
names.index('Ann')
# 0
```

###### длина списка *len(список)*

```python
len(names)
# 6
```

###### Посчитать количекства вхождений любого элемента в списке

```python
a = [1,1,1,2,3,4]
a.count(1)
# 3
```

###### Обратить последовательность в списке

```python
a.reverse()
#[4,3,2,1,1,1]

# или

a[::-1]
#[4,3,2,1,1,1]
```

###### Удаление и возврат элемента по индексу(по умолчанию последний элемент) с помощью pop([индекс])

```python
names.pop() # 'Sia'
```

###### Перебор элементов списка

```python
for element in my_list:
    print(element)
```